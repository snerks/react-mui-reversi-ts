{"version":3,"sources":["components/Header.tsx","components/GameCell.tsx","components/GameFinishedSnackBar.tsx","services/GameBoardService.ts","components/GameBoardList.tsx","components/GamePageList.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["useStyles","makeStyles","typographyStyles","flex","Header","isDarkMode","setIsDarkMode","classes","AppBar","position","Toolbar","Typography","className","Paper","title","Switch","checked","onChange","theme","createStyles","root","margin","cell","display","justifyContent","backgroundColor","height","alignItems","token","breakpoints","up","fontSize","validCellMarker","GameCell","props","row","column","isWhite","handleClick","isValid","currentPlayerIsWhite","isOccupied","undefined","discColor","emptyCellContent","style","color","cursor","content","onClick","palette","info","main","GameFinishedSnackbar","message","React","useState","open","setOpen","useEffect","handleClose","event","reason","Snackbar","anchorOrigin","vertical","horizontal","autoHideDuration","onClose","action","IconButton","size","aria-label","boardCellScores","consoleTableOrLog","value","console","table","log","getHeuristicValue","boardState","map","item","index","filter","itemIndex","reduce","accumulator","currentValue","alphabeta","depth","alpha","beta","validCellIndices","getValidCellIndices","haveNoValidMoves","length","heuristicValue","Infinity","validCellIndex","nextBoardState","getNextBoardState","Math","max","min","boardPlacedCellIndex","capturedCellIndices","getCapturedCellIndices","nextBoard","i","push","currentGameCellIsWhiteStatus","indexOf","cellIndexRankMap","Map","set","getBoardCellIndex","rowIndex","columnIndex","Number","isInteger","Error","getAdjacentCellStatusAndIndex","rowOffest","columnOffset","candidateCellLineItemRowIndex","candidateCellLineItemColumnIndex","candidateCellLineItemIndex","status","getAdjacentCellLine","adjacentCellStatusAndIndex","result","items","currentRowIndex","currentColumnIndex","getAdjacentCellLines","results","boardCellIndex","adjacentCellLines","adjacentCellLine","adjacentOpponentCellCount","adjacentOppentCellIndices","currentAdjacentCellStatusAndIndex","adjacentCellIsWhiteStatus","emptyCellStatusAndIndexItems","gameCellIsWhiteStatus","emptyCell","emptyCellsWithAdjacentOpponentCell","emptyCellStatusAndIndexItem","adjacentCellIsPopulated","bgColor","type","primary","currentCountContainer","padding","initialGameBoard","GameBoardList","initialBoard","Array","from","e","cellNumbers","setBoardState","setCurrentPlayerIsWhite","passCount","setPassCount","gameMoves","setGameMoves","useTheme","useMediaQuery","selectComputedValidCell","validCellIndexOrNull","nextAlpha","getBoardCellCoords","handleCellClick","pass","nextGameMoves","undoLastMove","lastGameMove","isUndoComplete","pop","gameMove","getReplayedBoardState","emptyCells","whitePlayerCells","blackPlayerCells","isGameFinished","winnerName","whitePlayerCellCount","blackPlayerCellCount","validCells","currentPlayerContent","Grid","container","alignContent","xs","justify","Badge","showZero","overlap","badgeContent","sm","CircularProgress","GridList","cols","cellHeight","cellNumber","rowNumber","floor","rowCellNumber","isValidCell","GridListTile","key","BottomNavigation","newValue","showLabels","BottomNavigationAction","label","icon","GamePageList","App","createMuiTheme","green","secondary","ThemeProvider","elevation","square","paddingBottom","direction","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.5fcc42da.chunk.js","sourcesContent":["import React from \"react\";\r\nimport { AppBar, Toolbar, Typography, Switch, Paper } from \"@material-ui/core\";\r\nimport HighlightIcon from \"@material-ui/icons/HighlightOutlined\";\r\nimport { makeStyles } from \"@material-ui/styles\";\r\n\r\nconst useStyles = makeStyles(() => ({\r\n  typographyStyles: {\r\n    flex: 1\r\n  }\r\n}));\r\n\r\ninterface Props {\r\n  isDarkMode: boolean;\r\n  setIsDarkMode: Function;\r\n}\r\n\r\nconst Header: React.FC<Props> = ({ isDarkMode, setIsDarkMode }) => {\r\n  const classes = useStyles();\r\n  return (\r\n    <AppBar position=\"static\">\r\n      <Toolbar>\r\n        <Typography className={classes.typographyStyles}>\r\n          Material UI Reversi\r\n        </Typography>\r\n        <Paper title=\"use this switch for dark/light mode\">\r\n          <HighlightIcon />\r\n        </Paper>\r\n        <Switch checked={isDarkMode} onChange={() => setIsDarkMode(!isDarkMode)} />\r\n      </Toolbar>\r\n    </AppBar>\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","import * as React from 'react';\r\nimport FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';\r\nimport CheckIcon from '@material-ui/icons/Check';\r\nimport { makeStyles, createStyles } from '@material-ui/core';\r\n\r\nexport interface GameCellProps {\r\n    row: number;\r\n    column: number;\r\n\r\n    isWhite?: boolean;\r\n\r\n    isValid: boolean;\r\n\r\n    handleClick: (row: number, column: number) => void;\r\n\r\n    currentPlayerIsWhite: boolean;\r\n}\r\n\r\nconst useStyles = makeStyles((theme) =>\r\n    createStyles({\r\n        root: {\r\n            margin: \"15px 0\"\r\n        },\r\n        cell: {\r\n            display: \"flex\",\r\n            justifyContent: \"center\",\r\n            backgroundColor: \"green\",\r\n            height: \"100%\",\r\n            alignItems: \"center\"\r\n        },\r\n        token: {\r\n            // padding: theme.spacing(1),\r\n            [theme.breakpoints.up('xs')]: {\r\n                fontSize: 25,\r\n            },\r\n            [theme.breakpoints.up('sm')]: {\r\n                fontSize: 35,\r\n            },\r\n            [theme.breakpoints.up('md')]: {\r\n                fontSize: 40,\r\n            },\r\n            [theme.breakpoints.up('lg')]: {\r\n                fontSize: 50,\r\n            },\r\n            [theme.breakpoints.up('xl')]: {\r\n                fontSize: 60,\r\n            }\r\n        },\r\n        validCellMarker: {\r\n            // padding: theme.spacing(1),\r\n            [theme.breakpoints.up('xs')]: {\r\n                fontSize: 25,\r\n            },\r\n            [theme.breakpoints.up('sm')]: {\r\n                fontSize: 35,\r\n            },\r\n            [theme.breakpoints.up('md')]: {\r\n                fontSize: 40,\r\n            },\r\n            [theme.breakpoints.up('lg')]: {\r\n                fontSize: 50,\r\n            },\r\n            [theme.breakpoints.up('xl')]: {\r\n                fontSize: 60,\r\n            }\r\n        }\r\n    })\r\n);\r\n\r\nconst GameCell: React.FC<GameCellProps> = (props) => {\r\n\r\n    const classes = useStyles();\r\n\r\n    const { row, column, isWhite, handleClick, isValid, currentPlayerIsWhite } = props;\r\n\r\n    const isOccupied = isWhite !== undefined;\r\n\r\n    let discColor = isOccupied ? isWhite ? 'white' : 'black' : undefined;\r\n\r\n    // &nbsp;\r\n    let emptyCellText = '\\u00a0';\r\n\r\n    let emptyCellContent =\r\n        <span className={classes.validCellMarker} style={{ color: discColor, cursor: 'not-allowed' }}>{emptyCellText}</span>;\r\n\r\n    if (!isOccupied && isValid) {\r\n        // emptyCellText = '\\u2713';\r\n\r\n        discColor = currentPlayerIsWhite ? 'white' : 'black';\r\n\r\n        emptyCellContent =\r\n            <CheckIcon className={classes.validCellMarker} style={{ color: discColor }} />;\r\n    }\r\n\r\n    const discContent = isOccupied ? (\r\n        <FiberManualRecordIcon className={classes.token} style={{ color: discColor }} />\r\n    ) : emptyCellContent;\r\n\r\n    const content = discContent;\r\n\r\n    return (\r\n        <div\r\n            onClick={isOccupied ? () => { } : () => handleClick(row, column)}\r\n            style={{ cursor: isValid ? 'pointer' : 'not-allowed' }}\r\n        >\r\n            {content}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default GameCell;\r\n","import React, { useEffect } from 'react';\r\n// import Button from '@material-ui/core/Button';\r\nimport Snackbar from '@material-ui/core/Snackbar';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport CloseIcon from '@material-ui/icons/Close';\r\nimport { makeStyles, createStyles } from '@material-ui/core';\r\n\r\nconst useStyles = makeStyles((theme) => {\r\n\r\n    // const bgColor =\r\n    //     theme.palette.type === \"light\" ?\r\n    //         theme.palette.primary.main :\r\n    //         undefined;\r\n\r\n    return createStyles({\r\n        root: {\r\n            backgroundColor: theme.palette.info.main\r\n        },\r\n    });\r\n}\r\n);\r\n\r\ninterface Props {\r\n    message: string;\r\n}\r\n\r\nconst GameFinishedSnackbar: React.FC<Props> = ({ message }) => {\r\n    const classes = useStyles();\r\n\r\n    const [open, setOpen] = React.useState(false);\r\n\r\n    // const handleClick = () => {\r\n    //     setOpen(true);\r\n    // };\r\n\r\n    useEffect(() => {\r\n        setOpen(true);\r\n    }, [])\r\n\r\n    const handleClose = (event: React.SyntheticEvent | React.MouseEvent, reason?: string) => {\r\n        if (reason === 'clickaway') {\r\n            return;\r\n        }\r\n\r\n        setOpen(false);\r\n    };\r\n\r\n    return (\r\n        <div className={classes.root}>\r\n            {/* <Button onClick={handleClick}>Open simple snackbar</Button> */}\r\n            <Snackbar\r\n                anchorOrigin={{\r\n                    vertical: 'bottom',\r\n                    horizontal: 'center',\r\n                }}\r\n                open={open}\r\n                autoHideDuration={6000}\r\n                onClose={handleClose}\r\n                message={message}\r\n                action={\r\n                    <>\r\n                        {/* <Button color=\"secondary\" size=\"small\" onClick={handleClose}>\r\n              UNDO\r\n            </Button> */}\r\n                        <IconButton size=\"small\" aria-label=\"close\" color=\"inherit\" onClick={handleClose}>\r\n                            <CloseIcon fontSize=\"small\" />\r\n                        </IconButton>\r\n                    </>\r\n                }\r\n            />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default GameFinishedSnackbar;\r\n","import { GameCellIsWhiteStatus } from \"../types/CustomTypes\";\r\n\r\n// https://stackoverflow.com/questions/40166357/python-reversi-othello-ai-working-under-1-second\r\nconst boardCellScores = [\r\n  99, -8, 8, 6, 6, 8, -8, 99,\r\n  -8, -24, -4, -3, -3, -4, -24, -8,\r\n  8, -4, 7, 4, 4, 7, -4, 8,\r\n  6, -3, 4, 0, 0, 4, -3, 6,\r\n  6, -3, 4, 0, 0, 4, -3, 6,\r\n  8, -4, 7, 4, 4, 7, -4, 8,\r\n  -8, -24, -4, -3, -3, -4, -24, -8,\r\n  99, -8, 8, 6, 6, 8, -8, 99\r\n];\r\n\r\nexport interface GameMove {\r\n  currentPlayerIsWhite: boolean,\r\n  boardPlacedCellIndex: number\r\n}\r\n\r\nexport const consoleTableOrLog = (value: any) => {\r\n  if (console.table) {\r\n    console.table(value)\r\n  } else {\r\n    console.log(value);\r\n  }\r\n}\r\n\r\nexport const getHeuristicValue = (\r\n  boardState: GameCellIsWhiteStatus[],\r\n  currentPlayerIsWhite: boolean): number => {\r\n\r\n  const currentPlayerCellIndices = boardState.map((item, index) => {\r\n    if (item === undefined) {\r\n      return -1;\r\n    }\r\n\r\n    const isCurrentPlayerCell = (item === currentPlayerIsWhite);\r\n\r\n    if (!isCurrentPlayerCell) {\r\n      return index;\r\n    }\r\n\r\n    return -1;\r\n  });\r\n\r\n  const currentPlayerPopulatedCellIndices = currentPlayerCellIndices.filter(itemIndex => itemIndex > -1);\r\n\r\n  const reducer = (accumulator: number, currentValue: number): number => {\r\n    return accumulator + boardCellScores[currentValue];\r\n  }\r\n\r\n  const result = currentPlayerPopulatedCellIndices.reduce(reducer, 0);\r\n\r\n  return result;\r\n}\r\n\r\n// https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning\r\nexport const alphabeta = (\r\n  boardState: GameCellIsWhiteStatus[],\r\n  depth: number,\r\n  alpha: number,\r\n  beta: number,\r\n  currentPlayerIsWhite: boolean): number => {\r\n\r\n  const validCellIndices = getValidCellIndices(boardState, currentPlayerIsWhite);\r\n  const haveNoValidMoves = validCellIndices.length === 0;\r\n\r\n  if (depth === 0 || haveNoValidMoves) {\r\n    return getHeuristicValue(boardState, currentPlayerIsWhite);\r\n  }\r\n\r\n  let heuristicValue = 0;\r\n\r\n  if (currentPlayerIsWhite) {\r\n    heuristicValue = -Infinity;\r\n\r\n    for (let validCellIndex of validCellIndices) {\r\n      const nextBoardState = getNextBoardState(boardState, currentPlayerIsWhite, validCellIndex);\r\n      heuristicValue = getHeuristicValue(boardState, currentPlayerIsWhite);\r\n\r\n      heuristicValue =\r\n        Math.max(\r\n          heuristicValue,\r\n          alphabeta(nextBoardState, depth - 1, alpha, beta, false));\r\n\r\n      const nextAlpha = Math.max(alpha, heuristicValue);\r\n\r\n      if (nextAlpha >= beta) {\r\n        break; // (* β cut - off *)\r\n      }\r\n    }\r\n\r\n    return heuristicValue;\r\n  } else {\r\n    heuristicValue = Infinity;\r\n\r\n    // for each child of node do\r\n    //   value:= min(value, alphabeta(child, depth − 1, alpha, beta, TRUE))\r\n    //       beta := min(beta, value)\r\n    // if alpha ≥ beta then\r\n    // break (* alpha cut - off *)\r\n    // return value\r\n\r\n    for (let validCellIndex of validCellIndices) {\r\n      const nextBoardState = getNextBoardState(boardState, currentPlayerIsWhite, validCellIndex);\r\n      heuristicValue = getHeuristicValue(boardState, currentPlayerIsWhite);\r\n\r\n      heuristicValue =\r\n        Math.min(\r\n          heuristicValue,\r\n          alphabeta(nextBoardState, depth - 1, alpha, beta, true));\r\n\r\n      const nextBeta = Math.min(beta, heuristicValue);\r\n\r\n      if (alpha >= nextBeta) {\r\n        break; // (* alpha cut - off *)\r\n      }\r\n    }\r\n\r\n    return heuristicValue;\r\n  }\r\n}\r\n\r\nexport const getNextBoardState = (\r\n  boardState: GameCellIsWhiteStatus[],\r\n  currentPlayerIsWhite: boolean,\r\n  boardPlacedCellIndex: number\r\n): GameCellIsWhiteStatus[] => {\r\n\r\n  // console.log(\"getNextBoardState : Start\");\r\n  // console.log(\"getNextBoardState : boardState\", boardState);\r\n  // console.log(\"getNextBoardState : currentPlayerIsWhite\", currentPlayerIsWhite);\r\n  // console.log(\"getNextBoardState : boardPlacedCellIndex\", boardPlacedCellIndex);\r\n\r\n  const capturedCellIndices =\r\n    getCapturedCellIndices(boardState, currentPlayerIsWhite, boardPlacedCellIndex);\r\n\r\n  const nextBoard: GameCellIsWhiteStatus[] = [];\r\n\r\n  for (let i = 0; i < boardState.length; i++) {\r\n    if (i === boardPlacedCellIndex) {\r\n      nextBoard.push(currentPlayerIsWhite);\r\n    } else {\r\n      const currentGameCellIsWhiteStatus = boardState[i];\r\n\r\n      if (capturedCellIndices.indexOf(i) > -1) {\r\n        nextBoard.push(currentPlayerIsWhite);\r\n      } else {\r\n        nextBoard.push(currentGameCellIsWhiteStatus);\r\n      }\r\n    }\r\n  }\r\n\r\n  // console.log(\"handleCellClick : End : boardPlacedCellIndex\", boardPlacedCellIndex);\r\n\r\n  return nextBoard;\r\n}\r\n\r\nexport const getReplayedBoardState = (\r\n  boardState: GameCellIsWhiteStatus[],\r\n  gameMoves: GameMove[]\r\n): GameCellIsWhiteStatus[] => {\r\n\r\n  // console.log(\"getReplayedBoardState : Start\");\r\n\r\n  let nextBoardState: GameCellIsWhiteStatus[] = boardState;\r\n\r\n  for (let gameMove of gameMoves) {\r\n    nextBoardState =\r\n      getNextBoardState(\r\n        nextBoardState,\r\n        gameMove.currentPlayerIsWhite,\r\n        gameMove.boardPlacedCellIndex);\r\n  }\r\n\r\n  // console.log(\"handleCellClick : End : boardPlacedCellIndex\", boardPlacedCellIndex);\r\n\r\n  return nextBoardState;\r\n}\r\n\r\nconst cellIndexRankMap = new Map<number, number>();\r\n\r\n// Corner\r\ncellIndexRankMap.set(0, 6);\r\ncellIndexRankMap.set(7, 6);\r\ncellIndexRankMap.set(56, 6);\r\ncellIndexRankMap.set(63, 6);\r\n\r\n// Inner Edges\r\ncellIndexRankMap.set(2, 5);\r\ncellIndexRankMap.set(3, 5);\r\ncellIndexRankMap.set(4, 5);\r\ncellIndexRankMap.set(5, 5);\r\n\r\ncellIndexRankMap.set(16, 5);\r\ncellIndexRankMap.set(24, 5);\r\ncellIndexRankMap.set(32, 5);\r\ncellIndexRankMap.set(40, 5);\r\n\r\ncellIndexRankMap.set(23, 5);\r\ncellIndexRankMap.set(31, 5);\r\ncellIndexRankMap.set(39, 5);\r\ncellIndexRankMap.set(47, 5);\r\n\r\ncellIndexRankMap.set(57, 5);\r\ncellIndexRankMap.set(58, 5);\r\ncellIndexRankMap.set(59, 5);\r\ncellIndexRankMap.set(60, 5);\r\n\r\n// Inner corners\r\ncellIndexRankMap.set(18, 4);\r\ncellIndexRankMap.set(21, 4);\r\ncellIndexRankMap.set(42, 4);\r\ncellIndexRankMap.set(45, 4);\r\n\r\n// Others\r\n// Rank === 3\r\n\r\n// C Cells\r\ncellIndexRankMap.set(1, 2);\r\ncellIndexRankMap.set(6, 2);\r\ncellIndexRankMap.set(8, 2);\r\ncellIndexRankMap.set(15, 2);\r\n\r\ncellIndexRankMap.set(48, 2);\r\ncellIndexRankMap.set(55, 2);\r\ncellIndexRankMap.set(57, 2);\r\ncellIndexRankMap.set(62, 2);\r\n\r\n// X Cells\r\ncellIndexRankMap.set(9, 1);\r\ncellIndexRankMap.set(14, 1);\r\ncellIndexRankMap.set(49, 1);\r\ncellIndexRankMap.set(54, 1);\r\n\r\nexport interface CellRankAndIndex {\r\n  index: number;\r\n  rank: number;\r\n}\r\n\r\nexport const getCellRank = (cellIndex: number): CellRankAndIndex => {\r\n  if (cellIndexRankMap.has(cellIndex)) {\r\n    const rank = cellIndexRankMap.get(cellIndex);\r\n\r\n    if (rank === undefined) {\r\n      return {\r\n        index: cellIndex,\r\n        rank: 3\r\n      };\r\n    }\r\n\r\n    return {\r\n      index: cellIndex,\r\n      rank\r\n    };\r\n  }\r\n\r\n  return {\r\n    index: cellIndex,\r\n    rank: 3\r\n  };\r\n}\r\n\r\nexport interface CellStatusAndIndex {\r\n  index: number;\r\n  status: GameCellIsWhiteStatus;\r\n}\r\n\r\nexport interface CellLine {\r\n  items: CellStatusAndIndex[];\r\n}\r\n\r\ninterface RowColumnIndices {\r\n  rowIndex: number;\r\n  columnIndex: number;\r\n}\r\n\r\nexport const getRowColumnIndicesFromCellIndex = (\r\n  cellIndex: number\r\n): RowColumnIndices => {\r\n  if (!Number.isInteger(cellIndex)) {\r\n    throw new Error(\"cellIndex must be a whole number\");\r\n  }\r\n\r\n  if (cellIndex < 0) {\r\n    throw new Error(\"cellIndex must be greater than or equal to zero\");\r\n  }\r\n\r\n  if (cellIndex > 63) {\r\n    throw new Error(\"cellIndex must be less than or equal to 63\");\r\n  }\r\n\r\n  const rowIndex = Math.floor(cellIndex / 8);\r\n  const columnIndex = cellIndex % 8;\r\n\r\n  return {\r\n    rowIndex: rowIndex,\r\n    columnIndex: columnIndex,\r\n  };\r\n};\r\n\r\nexport const getBoardCellIndex = (rowIndex: number, columnIndex: number): number => {\r\n  if (!Number.isInteger(rowIndex)) {\r\n    throw new Error(\"rowIndex must be a whole number\");\r\n  }\r\n\r\n  if (!Number.isInteger(columnIndex)) {\r\n    throw new Error(\"columnIndex must be a whole number\");\r\n  }\r\n\r\n  if (rowIndex < 0) {\r\n    throw new Error(\"rowIndex must be greater than or equal to zero\");\r\n  }\r\n\r\n  if (rowIndex > 7) {\r\n    throw new Error(\"rowIndex must be less than or equal to 7\");\r\n  }\r\n\r\n  if (columnIndex < 0) {\r\n    throw new Error(\"columnIndex must be greater than or equal to zero\");\r\n  }\r\n\r\n  if (columnIndex > 7) {\r\n    throw new Error(\"columnIndex must be less than or equal to 7\");\r\n  }\r\n\r\n  return rowIndex * 8 + columnIndex;\r\n};\r\n\r\nconst getAdjacentCellStatusAndIndex = (\r\n  boardState: GameCellIsWhiteStatus[],\r\n  rowIndex: number,\r\n  columnIndex: number,\r\n  rowOffest: number,\r\n  columnOffset: number\r\n): CellStatusAndIndex | null => {\r\n  const candidateCellLineItemRowIndex = rowIndex + rowOffest;\r\n  const candidateCellLineItemColumnIndex = columnIndex + columnOffset;\r\n\r\n  const candidateCellLineItemRowIndexIsInRange =\r\n    candidateCellLineItemRowIndex > -1 && candidateCellLineItemRowIndex < 8;\r\n\r\n  const candidateCellLineItemColumnIndexIsInRange =\r\n    candidateCellLineItemColumnIndex > -1 &&\r\n    candidateCellLineItemColumnIndex < 8;\r\n\r\n  const candidateCellLineItemCoordsInRange =\r\n    candidateCellLineItemRowIndexIsInRange &&\r\n    candidateCellLineItemColumnIndexIsInRange;\r\n\r\n  if (!candidateCellLineItemCoordsInRange) {\r\n    return null;\r\n  }\r\n\r\n  const candidateCellLineItemIndex = getBoardCellIndex(\r\n    candidateCellLineItemRowIndex,\r\n    candidateCellLineItemColumnIndex\r\n  );\r\n\r\n  const candidateCellLineItemIsWhiteStatus =\r\n    boardState[candidateCellLineItemIndex];\r\n\r\n  return {\r\n    status: candidateCellLineItemIsWhiteStatus,\r\n    index: candidateCellLineItemIndex,\r\n  };\r\n};\r\n\r\nconst getAdjacentCellLine = (\r\n  boardState: GameCellIsWhiteStatus[],\r\n  rowIndex: number,\r\n  columnIndex: number,\r\n  rowOffest: number,\r\n  columnOffset: number\r\n): CellLine => {\r\n  const result: CellLine = {\r\n    items: [],\r\n  };\r\n\r\n  let currentRowIndex = rowIndex;\r\n  let currentColumnIndex = columnIndex;\r\n\r\n  let adjacentCellStatusAndIndex: CellStatusAndIndex | null;\r\n\r\n  do {\r\n    adjacentCellStatusAndIndex = getAdjacentCellStatusAndIndex(\r\n      boardState,\r\n      currentRowIndex,\r\n      currentColumnIndex,\r\n      rowOffest,\r\n      columnOffset\r\n    );\r\n\r\n    if (adjacentCellStatusAndIndex) {\r\n      result.items.push(adjacentCellStatusAndIndex);\r\n\r\n      currentRowIndex += rowOffest;\r\n      currentColumnIndex += columnOffset;\r\n    }\r\n  } while (!!adjacentCellStatusAndIndex);\r\n\r\n  return result;\r\n};\r\n\r\nexport const getAdjacentCellLines = (\r\n  boardState: GameCellIsWhiteStatus[],\r\n  rowIndex: number,\r\n  columnIndex: number\r\n): CellLine[] => {\r\n  const results: CellLine[] = [];\r\n\r\n  // start at 12 o'clock\r\n  // North\r\n  results.push(getAdjacentCellLine(boardState, rowIndex, columnIndex, -1, 0));\r\n  // NE\r\n  results.push(getAdjacentCellLine(boardState, rowIndex, columnIndex, -1, 1));\r\n  // East\r\n  results.push(getAdjacentCellLine(boardState, rowIndex, columnIndex, 0, 1));\r\n  // SE\r\n  results.push(getAdjacentCellLine(boardState, rowIndex, columnIndex, 1, 1));\r\n  // South\r\n  results.push(getAdjacentCellLine(boardState, rowIndex, columnIndex, 1, 0));\r\n  // SW\r\n  results.push(getAdjacentCellLine(boardState, rowIndex, columnIndex, 1, -1));\r\n  // West\r\n  results.push(getAdjacentCellLine(boardState, rowIndex, columnIndex, 0, -1));\r\n  // NW\r\n  results.push(getAdjacentCellLine(boardState, rowIndex, columnIndex, -1, -1));\r\n\r\n  return results;\r\n};\r\n\r\nexport const getCapturedCellIndices = (\r\n  boardState: GameCellIsWhiteStatus[],\r\n  currentPlayerIsWhite: boolean,\r\n  boardCellIndex: number\r\n): number[] => {\r\n  let results: number[] = [];\r\n\r\n  const columnIndex = boardCellIndex % 8;\r\n  const rowIndex = (boardCellIndex - columnIndex) / 8;\r\n\r\n  const adjacentCellLines = getAdjacentCellLines(\r\n    boardState,\r\n    rowIndex,\r\n    columnIndex\r\n  );\r\n\r\n  for (let adjacentCellLine of adjacentCellLines) {\r\n    if (adjacentCellLine.items.length) {\r\n      let adjacentOpponentCellCount = 0;\r\n      const adjacentOppentCellIndices: number[] = [];\r\n\r\n      for (let i = 0; i < adjacentCellLine.items.length; i++) {\r\n        let currentAdjacentCellStatusAndIndex = adjacentCellLine.items[i];\r\n\r\n        let adjacentCellIsWhiteStatus =\r\n          currentAdjacentCellStatusAndIndex.status;\r\n        let adjacentCellIsPopulated = adjacentCellIsWhiteStatus !== undefined;\r\n\r\n        if (!adjacentCellIsPopulated) {\r\n          break;\r\n        }\r\n\r\n        let adjacentCellIsOpponentCell = currentPlayerIsWhite\r\n          ? !adjacentCellIsWhiteStatus\r\n          : adjacentCellIsWhiteStatus;\r\n\r\n        if (adjacentCellIsOpponentCell) {\r\n          adjacentOpponentCellCount++;\r\n          adjacentOppentCellIndices.push(\r\n            currentAdjacentCellStatusAndIndex.index\r\n          );\r\n        } else {\r\n          // Is current player's cell\r\n          // Stop iteration\r\n          // Add captured sell indices to results\r\n          if (adjacentOpponentCellCount > 0) {\r\n            results = [...results, ...adjacentOppentCellIndices];\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return results;\r\n};\r\n\r\nexport const getValidCellIndices = (boardState: GameCellIsWhiteStatus[], currentPlayerIsWhite: boolean): number[] => {\r\n\r\n  const cellStatusAndIndexItems = boardState.map(\r\n    (gameCellIsWhiteStatus: GameCellIsWhiteStatus, index: number): CellStatusAndIndex => {\r\n      const isEmptyCell = gameCellIsWhiteStatus === undefined;\r\n\r\n      if (isEmptyCell) {\r\n        return {\r\n          status: gameCellIsWhiteStatus,\r\n          index\r\n        };\r\n      }\r\n\r\n      return {\r\n        status: gameCellIsWhiteStatus,\r\n        index: -1\r\n      };\r\n    });\r\n\r\n  const emptyCellStatusAndIndexItems = cellStatusAndIndexItems.filter(emptyCell => emptyCell.index > -1);\r\n\r\n  const emptyCellsWithAdjacentOpponentCell: CellStatusAndIndex[] = [];\r\n\r\n  for (let emptyCellStatusAndIndexItem of emptyCellStatusAndIndexItems) {\r\n    const column = emptyCellStatusAndIndexItem.index % 8;\r\n    const row = (emptyCellStatusAndIndexItem.index - column) / 8;\r\n\r\n    const adjacentCellLines = getAdjacentCellLines(boardState, row, column);\r\n\r\n    for (let adjacentCellLine of adjacentCellLines) {\r\n      if (adjacentCellLine.items.length) {\r\n\r\n        let adjacentOpponentCellCount = 0;\r\n\r\n        for (let i = 0; i < adjacentCellLine.items.length; i++) {\r\n          const currentAdjacentCellStatusAndIndex = adjacentCellLine.items[i];\r\n\r\n          const adjacentCellIsWhiteStatus = currentAdjacentCellStatusAndIndex.status;\r\n          const adjacentCellIsPopulated = adjacentCellIsWhiteStatus !== undefined;\r\n\r\n          if (!adjacentCellIsPopulated) {\r\n            break;\r\n          }\r\n\r\n          const adjacentCellIsOpponentCell = (\r\n            adjacentCellIsPopulated &&\r\n              currentPlayerIsWhite ?\r\n              !adjacentCellIsWhiteStatus : adjacentCellIsWhiteStatus\r\n          );\r\n\r\n          if (adjacentCellIsOpponentCell) {\r\n            adjacentOpponentCellCount++;\r\n          } else {\r\n            // Is current player's cell\r\n            if (adjacentOpponentCellCount > 0) {\r\n              emptyCellsWithAdjacentOpponentCell.push(emptyCellStatusAndIndexItem);\r\n            }\r\n\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return emptyCellsWithAdjacentOpponentCell.map(emptyCell => emptyCell.index);\r\n}\r\n","import React, {\r\n    useState,\r\n    useEffect\r\n} from \"react\";\r\nimport {\r\n    GridList,\r\n    GridListTile,\r\n    makeStyles,\r\n    createStyles,\r\n    Grid,\r\n    BottomNavigation,\r\n    BottomNavigationAction,\r\n    Badge,\r\n    CircularProgress,\r\n    LinearProgress,\r\n    Hidden,\r\n    Paper\r\n} from \"@material-ui/core\";\r\nimport { useTheme } from '@material-ui/core/styles';\r\nimport useMediaQuery from '@material-ui/core/useMediaQuery';\r\nimport FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';\r\nimport RestoreIcon from '@material-ui/icons/Restore';\r\nimport ShuffleIcon from '@material-ui/icons/Shuffle';\r\nimport SentimentVeryDissatisfiedIcon from '@material-ui/icons/SentimentVeryDissatisfied';\r\nimport RestorePageIcon from '@material-ui/icons/RestorePage';\r\nimport UndoIcon from '@material-ui/icons/Undo';\r\n\r\nimport { GameCellIsWhiteStatus } from \"../types/CustomTypes\";\r\nimport GameCell from \"./GameCell\";\r\nimport GameFinishedSnackbar from \"./GameFinishedSnackBar\";\r\nimport { getCapturedCellIndices, getBoardCellIndex, getValidCellIndices, getCellRank, getNextBoardState, alphabeta, GameMove, getReplayedBoardState, consoleTableOrLog } from \"../services/GameBoardService\";\r\n\r\nconst useStyles = makeStyles((theme) => {\r\n\r\n    const bgColor =\r\n        theme.palette.type === \"light\" ?\r\n            theme.palette.primary.main :\r\n            undefined;\r\n\r\n    return createStyles({\r\n        root: {\r\n            [theme.breakpoints.up('xs')]: {\r\n                margin: \"3px 0 0 0\"\r\n            },\r\n            [theme.breakpoints.up('sm')]: {\r\n                margin: \"15px 0 0 0\"\r\n            },\r\n        },\r\n        cell: {\r\n            display: \"flex\",\r\n            justifyContent: \"center\",\r\n            backgroundColor: \"green\",\r\n            height: \"100%\",\r\n            alignItems: \"center\"\r\n        },\r\n        token: {\r\n            // padding: theme.spacing(1),\r\n            [theme.breakpoints.up('xs')]: {\r\n                fontSize: 30,\r\n            },\r\n            [theme.breakpoints.up('sm')]: {\r\n                fontSize: 30,\r\n            },\r\n            [theme.breakpoints.up('md')]: {\r\n                fontSize: 40,\r\n            },\r\n            [theme.breakpoints.up('xl')]: {\r\n                fontSize: 60,\r\n            }\r\n        },\r\n        currentCountContainer: {\r\n            padding: \"20px 0 10px 0\",\r\n            backgroundColor: bgColor\r\n        }\r\n    });\r\n}\r\n);\r\n\r\nexport const initialGameBoard: GameCellIsWhiteStatus[] = [\r\n    undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, true, false, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, false, true, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,\r\n];\r\n\r\ninterface GameBoardListProps {\r\n    initialBoard: GameCellIsWhiteStatus[];\r\n}\r\n\r\nconst GameBoardList: React.FC<GameBoardListProps> = ({ initialBoard }) => {\r\n    const classes = useStyles();\r\n\r\n    const [cellNumbers] = useState(Array.from(initialBoard).map((e, i) => i));\r\n    const [boardState, setBoardState] = useState(initialBoard);\r\n    const [currentPlayerIsWhite, setCurrentPlayerIsWhite] = useState(false);\r\n    const [passCount, setPassCount] = useState(0);\r\n\r\n    const [gameMoves, setGameMoves] = useState<GameMove[]>([]);\r\n\r\n    const theme = useTheme();\r\n    const matches = useMediaQuery(theme.breakpoints.up('sm'));\r\n\r\n    console.log(\"currentPlayerIsWhite\", currentPlayerIsWhite);\r\n\r\n    // const selectComputedValidCell = () => {\r\n    //     const validCellOrNull = getComputedValidCellIndex();\r\n    //     if (validCellOrNull === null) {\r\n    //         pass();\r\n    //         return;\r\n    //     }\r\n\r\n    //     const { row, column } = getBoardCellCoords(validCellOrNull);\r\n\r\n    //     handleCellClick(row, column);\r\n    // }\r\n\r\n    //     possible_moves = self.get_available_moves(board,self.my_color,self.opponent_color)\r\n    // for [x, y] in possible_moves:\r\n    //     new_board = self.make_board_copy(board)\r\n    //     new_board[x][y] = self.my_color\r\n    //     new_alpha = self.minmax(new_board,1,alpha,beta)\r\n    //     if new_alpha > alpha:\r\n    //         alpha = new_alpha\r\n    //         best_move = [x,y]\r\n\r\n    const selectComputedValidCell = () => {\r\n        const validCellIndices = getValidCellIndices(boardState, currentPlayerIsWhite);\r\n        if (validCellIndices.length === 0) {\r\n            pass();\r\n            return;\r\n        }\r\n\r\n        let alpha = -Infinity;\r\n        const beta = Infinity;\r\n\r\n        let validCellIndexOrNull: number | null = null;\r\n\r\n        for (let validCellIndex of validCellIndices) {\r\n            const nextBoardState = getNextBoardState(boardState, currentPlayerIsWhite, validCellIndex);\r\n\r\n            // console.table(nextBoardState);\r\n\r\n            const nextAlpha = alphabeta(nextBoardState, 2, alpha, beta, false);\r\n\r\n            if (nextAlpha > alpha) {\r\n                alpha = nextAlpha;\r\n\r\n                validCellIndexOrNull = validCellIndex;\r\n            }\r\n        }\r\n\r\n        if (validCellIndexOrNull === null) {\r\n            pass();\r\n            return;\r\n        }\r\n\r\n        const { row, column } = getBoardCellCoords(validCellIndexOrNull);\r\n\r\n        handleCellClick(row, column);\r\n    }\r\n\r\n    useEffect(() => {\r\n        console.log(\"useEffect : currentPlayerIsWhite : \", currentPlayerIsWhite);\r\n\r\n        // Computer plays as white\r\n        if (currentPlayerIsWhite) {\r\n            selectComputedValidCell();\r\n            return;\r\n        }\r\n\r\n    }, [currentPlayerIsWhite]);\r\n\r\n    const handleCellClick = (row: number, column: number) => {\r\n        console.log(\"handleCellClick : Start\", row, column);\r\n\r\n        const boardPlacedCellIndex = getBoardCellIndex(row, column);\r\n\r\n        console.log(\"handleCellClick : boardPlacedCellIndex\", boardPlacedCellIndex);\r\n\r\n        console.log(\"handleCellClick : currentPlayerIsWhite\", currentPlayerIsWhite);\r\n\r\n        const capturedCellIndices =\r\n            getCapturedCellIndices(boardState, currentPlayerIsWhite, boardPlacedCellIndex);\r\n\r\n        const nextBoard: GameCellIsWhiteStatus[] = [];\r\n\r\n        for (let i = 0; i < boardState.length; i++) {\r\n            if (i === boardPlacedCellIndex) {\r\n                nextBoard.push(currentPlayerIsWhite);\r\n            } else {\r\n                const currentGameCellIsWhiteStatus = boardState[i];\r\n\r\n                if (capturedCellIndices.indexOf(i) > -1) {\r\n                    nextBoard.push(currentPlayerIsWhite);\r\n                } else {\r\n                    nextBoard.push(currentGameCellIsWhiteStatus);\r\n                }\r\n            }\r\n        }\r\n\r\n        setBoardState(nextBoard);\r\n        setCurrentPlayerIsWhite(!currentPlayerIsWhite);\r\n        setPassCount(0);\r\n\r\n        const nextGameMoves = [...gameMoves, { currentPlayerIsWhite, boardPlacedCellIndex }];\r\n        setGameMoves(nextGameMoves);\r\n        consoleTableOrLog(nextGameMoves);\r\n\r\n        console.log(\"handleCellClick : End\", row, column);\r\n    }\r\n\r\n    const restart = () => {\r\n        setBoardState(initialGameBoard);\r\n        setGameMoves([]);\r\n        setCurrentPlayerIsWhite(false);\r\n        setPassCount(0);\r\n    }\r\n\r\n    const pass = () => {\r\n        setCurrentPlayerIsWhite(!currentPlayerIsWhite);\r\n        setPassCount(passCount + 1);\r\n    }\r\n\r\n    const undoLastMove = () => {\r\n        if (gameMoves.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const nextGameMoves = [...gameMoves];\r\n\r\n        let lastGameMove: GameMove | null = null;\r\n        let isUndoComplete = false;\r\n\r\n        do {\r\n            lastGameMove = nextGameMoves[nextGameMoves.length - 1];\r\n\r\n            nextGameMoves.pop();\r\n\r\n            if (!lastGameMove.currentPlayerIsWhite) {\r\n                isUndoComplete = true;\r\n            }\r\n        } while (!isUndoComplete && nextGameMoves.length > 0)\r\n\r\n        consoleTableOrLog(nextGameMoves);\r\n\r\n        const nextBoardState = getReplayedBoardState(initialBoard, nextGameMoves);\r\n        setBoardState(nextBoardState);\r\n        setGameMoves(nextGameMoves);\r\n        setCurrentPlayerIsWhite(currentPlayerIsWhite);\r\n    }\r\n\r\n    const getBoardCellCoords = (index: number): { row: number, column: number } => {\r\n        const column = index % 8;\r\n        const row = (index - column) / 8;\r\n\r\n        return { row, column };\r\n    }\r\n\r\n    const getComputedValidCellIndex = (): number | null => {\r\n        const validCells = getValidCellIndices(boardState, currentPlayerIsWhite);\r\n        if (validCells.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const cellRankAndIndices = validCells.map(cellIndex => getCellRank(cellIndex));\r\n\r\n        cellRankAndIndices.sort((itemA, itemB) => itemA.rank - itemB.rank);\r\n        console.log(\"getComputedValidCellIndex\", cellRankAndIndices);\r\n\r\n        const randomValidCellAndIndex = cellRankAndIndices[cellRankAndIndices.length - 1];\r\n\r\n        console.log(\"getComputedValidCellIndex : result = \", randomValidCellAndIndex);\r\n\r\n        return randomValidCellAndIndex.index;\r\n    }\r\n\r\n    const getRandomValidCellIndex = (): number | null => {\r\n        const validCells = getValidCellIndices(boardState, currentPlayerIsWhite);\r\n        if (validCells.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const randomValidCellIndex = validCells[0];\r\n\r\n        return randomValidCellIndex;\r\n    }\r\n\r\n    const selectRandomValidCell = () => {\r\n        const validCellOrNull = getRandomValidCellIndex();\r\n        if (validCellOrNull === null) {\r\n            pass();\r\n            return;\r\n        }\r\n\r\n        const { row, column } = getBoardCellCoords(validCellOrNull);\r\n\r\n        handleCellClick(row, column);\r\n    }\r\n\r\n    const emptyCells = boardState.filter(item => item === undefined);\r\n    const whitePlayerCells = boardState.filter(item => item !== undefined && item);\r\n    const blackPlayerCells = boardState.filter(item => item !== undefined && !item);\r\n\r\n    const isGameFinished = (emptyCells.length === 0) || (passCount > 1);\r\n\r\n    let winnerName: string = '';\r\n\r\n    if (isGameFinished) {\r\n        const whitePlayerCellCount = whitePlayerCells.length;\r\n        const blackPlayerCellCount = blackPlayerCells.length;\r\n\r\n        if (whitePlayerCellCount === blackPlayerCellCount) {\r\n            winnerName = 'Neither: It was a Draw.';\r\n        } else {\r\n            winnerName = whitePlayerCellCount > blackPlayerCellCount ? 'White' : 'Black';\r\n        }\r\n    }\r\n\r\n    const validCells = getValidCellIndices(boardState, currentPlayerIsWhite);\r\n    console.log(\"currentPlayerIsWhite\", currentPlayerIsWhite);\r\n    console.log(\"validCells\", validCells);\r\n\r\n    const currentPlayerContent = (\r\n        <div className={classes.currentCountContainer} /* role=\"alert\" */ /* style={{ background: \"green\", padding: 15 }} */>\r\n\r\n            <Grid item container alignItems=\"center\" alignContent=\"space-between\">\r\n                <Grid item xs={2} />\r\n                <Grid item xs={3} container>\r\n                    <Grid item container justify=\"center\">\r\n                        <Badge color=\"secondary\" showZero overlap=\"circle\" badgeContent={whitePlayerCells.length}>\r\n                            <FiberManualRecordIcon className={classes.token} style={{ color: \"white\" }} />\r\n                        </Badge>\r\n                    </Grid>\r\n                </Grid>\r\n                <Grid item xs={2} container>\r\n                    {\r\n                        currentPlayerIsWhite &&\r\n\r\n                        <Grid item container alignItems=\"center\" alignContent=\"space-between\">\r\n                            <Grid item xs={1} sm={2} />\r\n                            <Grid item xs={10} sm={8} container>\r\n                                <Grid container justify=\"center\">\r\n                                    <CircularProgress color=\"secondary\" size={20} />\r\n                                </Grid>\r\n                            </Grid>\r\n                            <Grid item xs={1} sm={2} />\r\n                        </Grid>\r\n                    }\r\n                </Grid>\r\n                <Grid item xs={3} container>\r\n                    <Grid item container justify=\"center\">\r\n                        <Badge color=\"secondary\" showZero overlap=\"circle\" badgeContent={blackPlayerCells.length}>\r\n                            <FiberManualRecordIcon className={classes.token} style={{ color: \"black\" }} />\r\n                        </Badge>\r\n                    </Grid>\r\n                </Grid>\r\n                <Grid item xs={2} />\r\n            </Grid>\r\n\r\n            {\r\n                isGameFinished &&\r\n                <Grid item container alignItems=\"center\" alignContent=\"space-between\">\r\n                    <Grid item xs={1} sm={2} />\r\n                    <Grid item xs={10} sm={8} container>\r\n                        <Grid container justify=\"center\">\r\n                            <div style={{ fontSize: '14px' }}>\r\n                                <span>Winner is {winnerName}!</span>\r\n                            </div>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid item xs={1} sm={2} />\r\n                </Grid>\r\n            }\r\n            {\r\n                isGameFinished && passCount > 1 &&\r\n                <Grid item container>\r\n                    <Grid item xs={1} sm={2} />\r\n                    <Grid item xs={10} sm={8} alignItems=\"center\" alignContent=\"space-between\" container>\r\n                        <Grid container justify=\"center\">\r\n                            <div style={{ fontSize: '14px' }}>\r\n                                <span>Both players have passed - game finished early</span>\r\n                            </div>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid item xs={1} sm={2} />\r\n                </Grid>\r\n            }\r\n        </div>\r\n    );\r\n\r\n    return (\r\n        <div className={classes.root}>\r\n\r\n            <GridList cols={8} cellHeight=\"auto\">\r\n                {cellNumbers.map((cellNumber) => {\r\n                    const rowNumber = Math.floor(cellNumber / 8);\r\n                    const rowCellNumber = cellNumber % 8\r\n\r\n                    const isValidCell = validCells.indexOf(cellNumber) > -1;\r\n\r\n                    const noOp = () => { };\r\n                    const handleClickFunction = (row: number, column: number) => handleCellClick(row, column);\r\n\r\n                    return (\r\n                        <GridListTile key={cellNumber} cols={1} style={{ cursor: isValidCell ? 'pointer' : 'not-allowed' }}>\r\n                            <div className={classes.cell}>\r\n                                {/* <FiberManualRecordIcon className={classes.token} style={{ color: cellColor }} /> */}\r\n                                <GameCell\r\n                                    row={rowNumber}\r\n                                    column={rowCellNumber}\r\n                                    isWhite={boardState[cellNumber]}\r\n                                    handleClick={isValidCell ? handleClickFunction : noOp}\r\n                                    isValid={isValidCell}\r\n                                    currentPlayerIsWhite={currentPlayerIsWhite}\r\n                                />\r\n                            </div>\r\n                        </GridListTile>\r\n                    );\r\n                })}\r\n            </GridList>\r\n\r\n            {/* <h1>currentPlayerIsWhite = [{currentPlayerIsWhite ? \"Yes\" : \"No\"}]</h1> */}\r\n\r\n            <br />\r\n            {currentPlayerContent}\r\n\r\n            <BottomNavigation\r\n                value={null}\r\n                onChange={(event, newValue) => {\r\n                    // setValue(newValue);\r\n                    console.log(newValue);\r\n\r\n                    if (newValue === \"Restart\") {\r\n                        restart();\r\n                        return;\r\n                    }\r\n\r\n                    if (newValue === \"Random\") {\r\n                        // selectRandomValidCell();\r\n                        selectComputedValidCell();\r\n                        return;\r\n                    }\r\n\r\n                    if (newValue === \"Pass\") {\r\n                        pass();\r\n                        return;\r\n                    }\r\n\r\n                    if (newValue === \"UndoLastMove\") {\r\n                        undoLastMove();\r\n                        return;\r\n                    }\r\n                }}\r\n                showLabels\r\n                className={classes.root}\r\n            >\r\n                <BottomNavigationAction\r\n                    label=\"Restart\"\r\n                    value=\"Restart\"\r\n                    icon={<RestorePageIcon />} />\r\n\r\n                {\r\n                    !isGameFinished &&\r\n                    validCells.length > 0 &&\r\n                    <BottomNavigationAction\r\n                        label=\"Random\"\r\n                        value=\"Random\"\r\n                        icon={<ShuffleIcon />}\r\n                    />\r\n                }\r\n\r\n                {\r\n                    !isGameFinished &&\r\n                    gameMoves.length > 0 &&\r\n                    <BottomNavigationAction\r\n                        label=\"Undo\"\r\n                        value=\"UndoLastMove\"\r\n                        icon={<UndoIcon />}\r\n                    />\r\n                }\r\n\r\n                {\r\n                    // Must play, if valid cells are present\r\n                    !isGameFinished &&\r\n                    (validCells.length === 0) &&\r\n                    <BottomNavigationAction\r\n                        label=\"Must Pass!\"\r\n                        value=\"Pass\"\r\n                        icon={<SentimentVeryDissatisfiedIcon />} />\r\n                }\r\n            </BottomNavigation>\r\n\r\n            {/* <div>\r\n                <Hidden xsUp>\r\n                    <Paper>xsUp</Paper>\r\n                </Hidden>\r\n                <Hidden smUp>\r\n                    <Paper>smUp</Paper>\r\n                </Hidden>\r\n                <Hidden mdUp>\r\n                    <Paper>mdUp</Paper>\r\n                </Hidden>\r\n                <Hidden lgUp>\r\n                    <Paper>lgUp</Paper>\r\n                </Hidden>\r\n                <Hidden xlUp>\r\n                    <Paper>xlUp</Paper>\r\n                </Hidden>\r\n            </div> */}\r\n\r\n            {\r\n                isGameFinished &&\r\n                <GameFinishedSnackbar message={`Winner is ${winnerName}!`} />\r\n            }\r\n\r\n            {\r\n                !isGameFinished &&\r\n                !currentPlayerIsWhite &&\r\n                passCount > 0 &&\r\n                <GameFinishedSnackbar message={`Computer has passed!`} />\r\n            }\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default GameBoardList;","import * as React from 'react';\r\nimport GameBoardList, { initialGameBoard } from './GameBoardList';\r\n\r\nexport interface GamePageListProps {\r\n}\r\n\r\nclass GamePageList extends React.Component<GamePageListProps, {}> {\r\n    render(): JSX.Element {\r\n        return (\r\n            <GameBoardList initialBoard={initialGameBoard} />\r\n        );\r\n    }\r\n}\r\n\r\nexport default GamePageList;\r\n","import React, { useState } from 'react';\r\nimport { Paper, Grid, ThemeProvider, createMuiTheme } from \"@material-ui/core\";\r\nimport Header from './components/Header';\r\nimport GamePageList from './components/GamePageList';\r\nimport { green } from '@material-ui/core/colors';\r\n\r\nfunction App() {\r\n\r\n  const [isDarkMode, setIsDarkMode] = useState(true);\r\n\r\n  const theme = createMuiTheme({\r\n    palette: {\r\n      type: isDarkMode ? \"dark\" : \"light\",\r\n\r\n      primary: green,\r\n      secondary: green,\r\n    }\r\n  });\r\n\r\n  return (\r\n    <ThemeProvider theme={theme}>\r\n      <Paper elevation={0} square style={{ height: \"100%\" }}>\r\n        <div style={{ paddingBottom: 100 }}>\r\n          <Grid container direction=\"column\">\r\n            <Grid item>\r\n              <Header isDarkMode={isDarkMode} setIsDarkMode={setIsDarkMode} />\r\n            </Grid>\r\n            <Grid item container>\r\n              <Grid item xs={false} sm={1} />\r\n              <Grid item xs={12} sm={10}>\r\n                {/* <BoardList /> */}\r\n                <GamePageList />\r\n              </Grid>\r\n              <Grid item xs={false} sm={1} />\r\n            </Grid>\r\n          </Grid>\r\n        </div>\r\n      </Paper>\r\n    </ThemeProvider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import 'react-app-polyfill/ie11';\r\nimport 'react-app-polyfill/stable';\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  // <React.StrictMode>\r\n  <App />\r\n  // </React.StrictMode>\r\n  ,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}