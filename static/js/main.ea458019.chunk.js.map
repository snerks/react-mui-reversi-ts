{"version":3,"sources":["components/Header.tsx","components/GameCell.tsx","components/GameFinishedSnackBar.tsx","components/GameBoardList.tsx","components/GamePageList.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["useStyles","makeStyles","typographyStyles","flex","Header","isDarkMode","setIsDarkMode","classes","AppBar","position","Toolbar","Typography","className","Paper","title","Switch","checked","onChange","theme","createStyles","root","margin","cell","display","justifyContent","backgroundColor","height","alignItems","token","breakpoints","up","fontSize","validCellMarker","GameCell","props","row","column","isWhite","handleClick","isValid","currentPlayerIsWhite","isOccupied","undefined","discColor","emptyCellContent","style","color","content","onClick","cursor","GameFinishedSnackbar","message","React","useState","open","setOpen","useEffect","handleClose","event","reason","Snackbar","anchorOrigin","vertical","horizontal","autoHideDuration","onClose","action","IconButton","size","aria-label","bgColor","palette","type","primary","main","currentCountContainer","padding","initialGameBoard","GameBoardList","initialBoard","Array","from","map","e","i","cellNumbers","boardState","setBoardState","setCurrentPlayerIsWhite","passCount","setPassCount","console","log","selectRandomValidCell","getBoardCellIndex","getAdjacentCellStatusAndIndex","rowOffest","columnOffset","candidateCellLineItemRowIndex","candidateCellLineItemColumnIndex","candidateCellLineItemIndex","status","index","getAdjacentCellLines","result","push","getAdjacentCellLine","adjacentCellStatusAndIndex","items","currentRowIndex","currentColumnIndex","getValidCellIndices","board","emptyCellStatusAndIndexItems","gameCellIsWhiteStatus","filter","emptyCell","emptyCellsWithAdjacentOpponentCell","emptyCellStatusAndIndexItem","adjacentCellLines","adjacentCellLine","length","adjacentOpponentCellCount","adjacentCellIsWhiteStatus","adjacentCellIsPopulated","handleCellClick","boardCellIndex","capturedCellIndices","adjacentOppentCellIndices","currentAdjacentCellStatusAndIndex","getCapturedCellIndices","nextBoard","currentGameCellIsWhiteStatus","indexOf","pass","validCells","getBoardCellCoords","emptyCells","item","whitePlayerCells","blackPlayerCells","isGameFinished","winnerName","whitePlayerCellCount","blackPlayerCellCount","currentPlayerContent","Grid","container","alignContent","xs","justify","Badge","showZero","overlap","badgeContent","sm","GridList","cols","cellHeight","cellNumber","rowNumber","Math","floor","rowCellNumber","isValidCell","GridListTile","key","BottomNavigation","value","newValue","showLabels","BottomNavigationAction","label","icon","GamePageList","App","createMuiTheme","green","secondary","ThemeProvider","elevation","square","paddingBottom","direction","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error"],"mappings":"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","file":"static/js/main.ea458019.chunk.js","sourcesContent":["import React from \"react\";\r\nimport { AppBar, Toolbar, Typography, Switch, Paper } from \"@material-ui/core\";\r\nimport HighlightIcon from \"@material-ui/icons/HighlightOutlined\";\r\nimport { makeStyles } from \"@material-ui/styles\";\r\n\r\nconst useStyles = makeStyles(() => ({\r\n  typographyStyles: {\r\n    flex: 1\r\n  }\r\n}));\r\n\r\ninterface Props {\r\n  isDarkMode: boolean;\r\n  setIsDarkMode: Function;\r\n}\r\n\r\nconst Header: React.FC<Props> = ({ isDarkMode, setIsDarkMode }) => {\r\n  const classes = useStyles();\r\n  return (\r\n    <AppBar position=\"static\">\r\n      <Toolbar>\r\n        <Typography className={classes.typographyStyles}>\r\n          Material UI Reversi Sample\r\n        </Typography>\r\n        <Paper title=\"use this switch for dark/light mode\">\r\n          <HighlightIcon />\r\n        </Paper>\r\n        <Switch checked={isDarkMode} onChange={() => setIsDarkMode(!isDarkMode)} />\r\n      </Toolbar>\r\n    </AppBar>\r\n  );\r\n};\r\n\r\nexport default Header;\r\n","import * as React from 'react';\r\nimport FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';\r\nimport CheckIcon from '@material-ui/icons/Check';\r\nimport { makeStyles, createStyles } from '@material-ui/core';\r\n\r\nexport interface GameCellProps {\r\n    row: number;\r\n    column: number;\r\n\r\n    isWhite?: boolean;\r\n\r\n    isValid: boolean;\r\n\r\n    handleClick: (row: number, column: number) => void;\r\n\r\n    currentPlayerIsWhite: boolean;\r\n}\r\n\r\nconst useStyles = makeStyles((theme) =>\r\n    createStyles({\r\n        root: {\r\n            margin: \"15px 0\"\r\n        },\r\n        cell: {\r\n            display: \"flex\",\r\n            justifyContent: \"center\",\r\n            backgroundColor: \"green\",\r\n            height: \"100%\",\r\n            alignItems: \"center\"\r\n        },\r\n        token: {\r\n            // padding: theme.spacing(1),\r\n            [theme.breakpoints.up('xs')]: {\r\n                fontSize: 25,\r\n            },\r\n            [theme.breakpoints.up('sm')]: {\r\n                fontSize: 30,\r\n            },\r\n            [theme.breakpoints.up('md')]: {\r\n                fontSize: 40,\r\n            },\r\n            [theme.breakpoints.up('lg')]: {\r\n                fontSize: 60,\r\n            }\r\n        },\r\n        validCellMarker: {\r\n            // padding: theme.spacing(1),\r\n            [theme.breakpoints.up('xs')]: {\r\n                fontSize: 25,\r\n            },\r\n            [theme.breakpoints.up('sm')]: {\r\n                fontSize: 30,\r\n            },\r\n            [theme.breakpoints.up('md')]: {\r\n                fontSize: 40,\r\n            },\r\n            [theme.breakpoints.up('lg')]: {\r\n                fontSize: 60,\r\n            },\r\n        }\r\n    })\r\n);\r\n\r\nconst GameCell: React.FC<GameCellProps> = (props) => {\r\n\r\n    const classes = useStyles();\r\n\r\n    const { row, column, isWhite, handleClick, isValid, currentPlayerIsWhite } = props;\r\n\r\n    const isOccupied = isWhite !== undefined;\r\n\r\n    let discColor = isOccupied ? isWhite ? 'white' : 'black' : undefined;\r\n\r\n    // &nbsp;\r\n    let emptyCellText = '\\u00a0';\r\n\r\n    let emptyCellContent =\r\n        <span className={classes.validCellMarker} style={{ color: discColor }}>{emptyCellText}</span>;\r\n\r\n    if (!isOccupied && isValid) {\r\n        // emptyCellText = '\\u2713';\r\n\r\n        discColor = currentPlayerIsWhite ? 'white' : 'black';\r\n\r\n        emptyCellContent =\r\n            <CheckIcon className={classes.validCellMarker} style={{ color: discColor }} />;\r\n    }\r\n\r\n    const discContent = isOccupied ? (\r\n        <FiberManualRecordIcon className={classes.token} style={{ color: discColor }} />\r\n    ) : emptyCellContent;\r\n\r\n    const content = discContent;\r\n\r\n    return (\r\n        <div\r\n            onClick={isOccupied ? () => { } : () => handleClick(row, column)}\r\n            style={{ cursor: isValid ? 'pointer' : 'not-allowed' }}\r\n        >\r\n            {content}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default GameCell;\r\n","import React, { useEffect } from 'react';\r\n// import Button from '@material-ui/core/Button';\r\nimport Snackbar from '@material-ui/core/Snackbar';\r\nimport IconButton from '@material-ui/core/IconButton';\r\nimport CloseIcon from '@material-ui/icons/Close';\r\n\r\ninterface Props {\r\n    message: string;\r\n}\r\n\r\nconst GameFinishedSnackbar: React.FC<Props> = ({ message }) => {\r\n    const [open, setOpen] = React.useState(false);\r\n\r\n    // const handleClick = () => {\r\n    //     setOpen(true);\r\n    // };\r\n\r\n    useEffect(() => {\r\n        setOpen(true);\r\n    }, [])\r\n\r\n    const handleClose = (event: React.SyntheticEvent | React.MouseEvent, reason?: string) => {\r\n        if (reason === 'clickaway') {\r\n            return;\r\n        }\r\n\r\n        setOpen(false);\r\n    };\r\n\r\n    return (\r\n        <div>\r\n            {/* <Button onClick={handleClick}>Open simple snackbar</Button> */}\r\n            <Snackbar\r\n                anchorOrigin={{\r\n                    vertical: 'bottom',\r\n                    horizontal: 'center',\r\n                }}\r\n                open={open}\r\n                autoHideDuration={6000}\r\n                onClose={handleClose}\r\n                message={message}\r\n                action={\r\n                    <>\r\n                        {/* <Button color=\"secondary\" size=\"small\" onClick={handleClose}>\r\n              UNDO\r\n            </Button> */}\r\n                        <IconButton size=\"small\" aria-label=\"close\" color=\"inherit\" onClick={handleClose}>\r\n                            <CloseIcon fontSize=\"small\" />\r\n                        </IconButton>\r\n                    </>\r\n                }\r\n            />\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default GameFinishedSnackbar;\r\n","import React, {\r\n    useState,\r\n    useEffect\r\n} from \"react\";\r\nimport {\r\n    GridList,\r\n    GridListTile,\r\n    makeStyles,\r\n    createStyles,\r\n    Grid,\r\n    BottomNavigation,\r\n    BottomNavigationAction,\r\n    Badge\r\n} from \"@material-ui/core\";\r\nimport FiberManualRecordIcon from '@material-ui/icons/FiberManualRecord';\r\nimport RestoreIcon from '@material-ui/icons/Restore';\r\nimport ShuffleIcon from '@material-ui/icons/Shuffle';\r\nimport SentimentVeryDissatisfiedIcon from '@material-ui/icons/SentimentVeryDissatisfied';\r\n\r\nimport { GameCellIsWhiteStatus } from \"../types/CustomTypes\";\r\nimport GameCell from \"./GameCell\";\r\nimport GameFinishedSnackbar from \"./GameFinishedSnackBar\";\r\n\r\nconst useStyles = makeStyles((theme) => {\r\n\r\n    const bgColor =\r\n        theme.palette.type === \"light\" ?\r\n            theme.palette.primary.main :\r\n            undefined;\r\n\r\n    return createStyles({\r\n        root: {\r\n            margin: \"15px 0\"\r\n        },\r\n        cell: {\r\n            display: \"flex\",\r\n            justifyContent: \"center\",\r\n            backgroundColor: \"green\",\r\n            height: \"100%\",\r\n            alignItems: \"center\"\r\n        },\r\n        token: {\r\n            // padding: theme.spacing(1),\r\n            [theme.breakpoints.up('xs')]: {\r\n                fontSize: 30,\r\n            },\r\n            [theme.breakpoints.up('sm')]: {\r\n                fontSize: 30,\r\n            },\r\n            [theme.breakpoints.up('md')]: {\r\n                fontSize: 40,\r\n            },\r\n            [theme.breakpoints.up('lg')]: {\r\n                fontSize: 60,\r\n            }\r\n        },\r\n        currentCountContainer: {\r\n            padding: \"20px 0 10px 0\",\r\n            backgroundColor: bgColor\r\n        }\r\n    });\r\n}\r\n);\r\n\r\nexport const initialGameBoard: GameCellIsWhiteStatus[] = [\r\n    undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, true, false, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, false, true, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,\r\n    undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined,\r\n];\r\n\r\ninterface CellStatusAndIndex {\r\n    status: GameCellIsWhiteStatus;\r\n    index: number;\r\n}\r\n\r\ninterface CellLine {\r\n    items: CellStatusAndIndex[];\r\n}\r\n\r\ninterface GameBoardListProps {\r\n    initialBoard: GameCellIsWhiteStatus[];\r\n}\r\n\r\nconst GameBoardList: React.FC<GameBoardListProps> = ({ initialBoard }) => {\r\n    const classes = useStyles();\r\n\r\n    const [cellNumbers] = useState(Array.from(initialBoard).map((e, i) => i));\r\n    const [boardState, setBoardState] = useState(initialBoard);\r\n    const [currentPlayerIsWhite, setCurrentPlayerIsWhite] = useState(false);\r\n    const [passCount, setPassCount] = useState(0);\r\n\r\n    console.log(\"currentPlayerIsWhite\", currentPlayerIsWhite);\r\n\r\n    useEffect(() => {\r\n        console.log(\"useEffect : currentPlayerIsWhite : \", currentPlayerIsWhite);\r\n\r\n        // Computer plays as white\r\n        if (currentPlayerIsWhite) {\r\n            selectRandomValidCell();\r\n            return;\r\n        }\r\n\r\n    }, [currentPlayerIsWhite]);\r\n\r\n    const getCapturedCellIndices = (currentPlayerIsWhite: boolean, boardCellIndex: number): number[] => {\r\n        let result: number[] = [];\r\n\r\n        const column = boardCellIndex % 8;\r\n        const row = (boardCellIndex - column) / 8;\r\n\r\n        const adjacentCellLines = getAdjacentCellLines(row, column);\r\n\r\n        for (let adjacentCellLine of adjacentCellLines) {\r\n            if (adjacentCellLine.items.length) {\r\n\r\n                let adjacentOpponentCellCount = 0;\r\n                const adjacentOppentCellIndices: number[] = [];\r\n\r\n                for (let i = 0; i < adjacentCellLine.items.length; i++) {\r\n                    let currentAdjacentCellStatusAndIndex = adjacentCellLine.items[i];\r\n\r\n                    let adjacentCellIsWhiteStatus = currentAdjacentCellStatusAndIndex.status;\r\n                    let adjacentCellIsPopulated = adjacentCellIsWhiteStatus !== undefined;\r\n\r\n                    if (!adjacentCellIsPopulated) {\r\n                        break;\r\n                    }\r\n\r\n                    let adjacentCellIsOpponentCell = (\r\n                        adjacentCellIsPopulated &&\r\n                            currentPlayerIsWhite ?\r\n                            !adjacentCellIsWhiteStatus : adjacentCellIsWhiteStatus\r\n                    );\r\n\r\n                    if (adjacentCellIsOpponentCell) {\r\n                        adjacentOpponentCellCount++;\r\n                        adjacentOppentCellIndices.push(currentAdjacentCellStatusAndIndex.index);\r\n                    } else {\r\n                        // Is current player's cell\r\n                        if (adjacentOpponentCellCount > 0) {\r\n                            result = [\r\n                                ...result,\r\n                                ...adjacentOppentCellIndices\r\n                            ];\r\n                        }\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    const getBoardCellIndex = (row: number, column: number): number => {\r\n        return row * 8 + column;\r\n    }\r\n\r\n    const getAdjacentCellStatusAndIndex = (\r\n        row: number,\r\n        column: number,\r\n        rowOffest: number,\r\n        columnOffset: number\r\n    ): CellStatusAndIndex | null => {\r\n\r\n        const candidateCellLineItemRowIndex = row + rowOffest;\r\n        const candidateCellLineItemColumnIndex = column + columnOffset;\r\n\r\n        const candidateCellLineItemRowIndexIsInRange =\r\n            candidateCellLineItemRowIndex > -1 &&\r\n            candidateCellLineItemRowIndex < 8;\r\n\r\n        const candidateCellLineItemColumnIndexIsInRange =\r\n            candidateCellLineItemColumnIndex > -1 &&\r\n            candidateCellLineItemColumnIndex < 8;\r\n\r\n        const candidateCellLineItemCoordsInRange =\r\n            candidateCellLineItemRowIndexIsInRange &&\r\n            candidateCellLineItemColumnIndexIsInRange;\r\n\r\n        if (!candidateCellLineItemCoordsInRange) {\r\n            return null;\r\n        }\r\n\r\n        const candidateCellLineItemIndex =\r\n            getBoardCellIndex(candidateCellLineItemRowIndex, candidateCellLineItemColumnIndex);\r\n\r\n        const candidateCellLineItemIsWhiteStatus = boardState[candidateCellLineItemIndex];\r\n\r\n        return {\r\n            status: candidateCellLineItemIsWhiteStatus,\r\n            index: candidateCellLineItemIndex\r\n        };\r\n    }\r\n\r\n    const getAdjacentCellLines = (row: number, column: number): CellLine[] => {\r\n\r\n        const result: CellLine[] = [];\r\n\r\n        // start at 12 o'clock\r\n        result.push(getAdjacentCellLine(row, column, -1, 0));\r\n        result.push(getAdjacentCellLine(row, column, -1, 1));\r\n        result.push(getAdjacentCellLine(row, column, 0, 1));\r\n        result.push(getAdjacentCellLine(row, column, 1, 1));\r\n        result.push(getAdjacentCellLine(row, column, 1, 0));\r\n        result.push(getAdjacentCellLine(row, column, 1, -1));\r\n        result.push(getAdjacentCellLine(row, column, 0, -1));\r\n        result.push(getAdjacentCellLine(row, column, -1, -1));\r\n\r\n        return result;\r\n    }\r\n\r\n    const getAdjacentCellLine = (\r\n        row: number,\r\n        column: number,\r\n        rowOffest: number,\r\n        columnOffset: number): CellLine => {\r\n\r\n        const result: CellLine = {\r\n            items: []\r\n        };\r\n\r\n        let currentRowIndex = row;\r\n        let currentColumnIndex = column;\r\n\r\n        let adjacentCellStatusAndIndex: CellStatusAndIndex | null;\r\n\r\n        do {\r\n            adjacentCellStatusAndIndex =\r\n                getAdjacentCellStatusAndIndex(\r\n                    currentRowIndex,\r\n                    currentColumnIndex,\r\n                    rowOffest,\r\n                    columnOffset\r\n                );\r\n\r\n            if (adjacentCellStatusAndIndex) {\r\n                result.items.push(adjacentCellStatusAndIndex);\r\n\r\n                currentRowIndex += rowOffest;\r\n                currentColumnIndex += columnOffset;\r\n            }\r\n        } while (!!adjacentCellStatusAndIndex);\r\n\r\n        return result;\r\n    }\r\n\r\n    const getValidCellIndices = (board: GameCellIsWhiteStatus[], currentPlayerIsWhite: boolean): number[] => {\r\n\r\n        const cellStatusAndIndexItems = board.map(\r\n            (gameCellIsWhiteStatus: GameCellIsWhiteStatus, index: number): CellStatusAndIndex => {\r\n                const isEmptyCell = gameCellIsWhiteStatus === undefined;\r\n\r\n                if (isEmptyCell) {\r\n                    return {\r\n                        status: gameCellIsWhiteStatus,\r\n                        index\r\n                    };\r\n                }\r\n\r\n                return {\r\n                    status: gameCellIsWhiteStatus,\r\n                    index: -1\r\n                };\r\n            });\r\n\r\n        const emptyCellStatusAndIndexItems = cellStatusAndIndexItems.filter(emptyCell => emptyCell.index > -1);\r\n\r\n        const emptyCellsWithAdjacentOpponentCell: CellStatusAndIndex[] = [];\r\n\r\n        for (let emptyCellStatusAndIndexItem of emptyCellStatusAndIndexItems) {\r\n            const column = emptyCellStatusAndIndexItem.index % 8;\r\n            const row = (emptyCellStatusAndIndexItem.index - column) / 8;\r\n\r\n            const adjacentCellLines = getAdjacentCellLines(row, column);\r\n\r\n            for (let adjacentCellLine of adjacentCellLines) {\r\n                if (adjacentCellLine.items.length) {\r\n\r\n                    let adjacentOpponentCellCount = 0;\r\n\r\n                    for (let i = 0; i < adjacentCellLine.items.length; i++) {\r\n                        const currentAdjacentCellStatusAndIndex = adjacentCellLine.items[i];\r\n\r\n                        const adjacentCellIsWhiteStatus = currentAdjacentCellStatusAndIndex.status;\r\n                        const adjacentCellIsPopulated = adjacentCellIsWhiteStatus !== undefined;\r\n\r\n                        if (!adjacentCellIsPopulated) {\r\n                            break;\r\n                        }\r\n\r\n                        const adjacentCellIsOpponentCell = (\r\n                            adjacentCellIsPopulated &&\r\n                                currentPlayerIsWhite ?\r\n                                !adjacentCellIsWhiteStatus : adjacentCellIsWhiteStatus\r\n                        );\r\n\r\n                        if (adjacentCellIsOpponentCell) {\r\n                            adjacentOpponentCellCount++;\r\n                        } else {\r\n                            // Is current player's cell\r\n                            if (adjacentOpponentCellCount > 0) {\r\n                                emptyCellsWithAdjacentOpponentCell.push(emptyCellStatusAndIndexItem);\r\n                            }\r\n\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return emptyCellsWithAdjacentOpponentCell.map(emptyCell => emptyCell.index);\r\n    }\r\n\r\n    const handleCellClick = (row: number, column: number) => {\r\n        console.log(\"handleCellClick : Start\", row, column);\r\n\r\n        const boardCellIndex = getBoardCellIndex(row, column);\r\n\r\n        console.log(\"handleCellClick : currentPlayerIsWhite\", currentPlayerIsWhite);\r\n\r\n        const capturedCellIndices =\r\n            getCapturedCellIndices(currentPlayerIsWhite, boardCellIndex);\r\n\r\n        const nextBoard: GameCellIsWhiteStatus[] = [];\r\n\r\n        for (let i = 0; i < boardState.length; i++) {\r\n            if (i === boardCellIndex) {\r\n                nextBoard.push(currentPlayerIsWhite);\r\n            } else {\r\n                const currentGameCellIsWhiteStatus = boardState[i];\r\n\r\n                if (capturedCellIndices.indexOf(i) > -1) {\r\n                    nextBoard.push(currentPlayerIsWhite);\r\n                } else {\r\n                    nextBoard.push(currentGameCellIsWhiteStatus);\r\n                }\r\n            }\r\n        }\r\n\r\n        setBoardState(nextBoard);\r\n        setCurrentPlayerIsWhite(!currentPlayerIsWhite);\r\n        setPassCount(0);\r\n\r\n        console.log(\"handleCellClick : End\", row, column);\r\n    }\r\n\r\n    const restart = () => {\r\n        setBoardState(initialGameBoard);\r\n        setCurrentPlayerIsWhite(false);\r\n        setPassCount(0);\r\n    }\r\n\r\n    const pass = () => {\r\n        setCurrentPlayerIsWhite(!currentPlayerIsWhite);\r\n        setPassCount(passCount + 1);\r\n    }\r\n\r\n    const getBoardCellCoords = (index: number): { row: number, column: number } => {\r\n        const column = index % 8;\r\n        const row = (index - column) / 8;\r\n\r\n        return { row, column };\r\n    }\r\n\r\n    const selectRandomValidCell = () => {\r\n        const validCells = getValidCellIndices(boardState, currentPlayerIsWhite);\r\n        if (validCells.length === 0) {\r\n            pass();\r\n            return;\r\n        }\r\n\r\n        const randomValidCellIndex = validCells[0];\r\n\r\n        const { row, column } = getBoardCellCoords(randomValidCellIndex);\r\n\r\n        handleCellClick(row, column);\r\n    }\r\n\r\n    const emptyCells = boardState.filter(item => item === undefined);\r\n    const whitePlayerCells = boardState.filter(item => item !== undefined && item);\r\n    const blackPlayerCells = boardState.filter(item => item !== undefined && !item);\r\n\r\n    const isGameFinished = (emptyCells.length === 0) || (passCount > 1);\r\n\r\n    let winnerName: string = '';\r\n\r\n    if (isGameFinished) {\r\n        const whitePlayerCellCount = whitePlayerCells.length;\r\n        const blackPlayerCellCount = blackPlayerCells.length;\r\n\r\n        if (whitePlayerCellCount === blackPlayerCellCount) {\r\n            winnerName = 'Neither: It was a Draw.';\r\n        } else {\r\n            winnerName = whitePlayerCellCount > blackPlayerCellCount ? 'White' : 'Black';\r\n        }\r\n    }\r\n\r\n    const validCells = getValidCellIndices(boardState, currentPlayerIsWhite);\r\n    console.log(\"currentPlayerIsWhite\", currentPlayerIsWhite);\r\n    console.log(\"validCells\", validCells);\r\n\r\n    const currentPlayerContent = (\r\n        <div className={classes.currentCountContainer} /* role=\"alert\" */ /* style={{ background: \"green\", padding: 15 }} */>\r\n            <Grid item container alignItems=\"center\" alignContent=\"space-between\">\r\n                <Grid item xs={3} />\r\n                <Grid item xs={3} container>\r\n                    <Grid item container justify=\"center\">\r\n                        <Badge color=\"secondary\" showZero overlap=\"circle\" badgeContent={whitePlayerCells.length}>\r\n                            <FiberManualRecordIcon className={classes.token} style={{ color: \"white\" }} />\r\n                        </Badge>\r\n                    </Grid>\r\n                </Grid>\r\n                <Grid item xs={3} container>\r\n                    <Grid item container justify=\"center\">\r\n                        <Badge color=\"secondary\" showZero overlap=\"circle\" badgeContent={blackPlayerCells.length}>\r\n                            <FiberManualRecordIcon className={classes.token} style={{ color: \"black\" }} />\r\n                        </Badge>\r\n                    </Grid>\r\n                </Grid>\r\n                <Grid item xs={3} />\r\n            </Grid>\r\n\r\n            {\r\n                isGameFinished &&\r\n                <Grid item container alignItems=\"center\" alignContent=\"space-between\">\r\n                    <Grid item xs={1} sm={2} />\r\n                    <Grid item xs={10} sm={8} container>\r\n                        <Grid container justify=\"center\">\r\n                            <div style={{ fontSize: '14px' }}>\r\n                                <span>Winner is {winnerName}!</span>\r\n                            </div>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid item xs={1} sm={2} />\r\n                </Grid>\r\n            }\r\n            {\r\n                isGameFinished && passCount > 1 &&\r\n                <Grid item container>\r\n                    <Grid item xs={1} sm={2} />\r\n                    <Grid item xs={10} sm={8} alignItems=\"center\" alignContent=\"space-between\" container>\r\n                        <Grid container justify=\"center\">\r\n                            <div style={{ fontSize: '14px' }}>\r\n                                <span>Both players have passed - game finished early</span>\r\n                            </div>\r\n                        </Grid>\r\n                    </Grid>\r\n                    <Grid item xs={1} sm={2} />\r\n                </Grid>\r\n            }\r\n        </div>\r\n    );\r\n\r\n    return (\r\n        <div className={classes.root}>\r\n\r\n            <GridList cols={8} cellHeight=\"auto\">\r\n                {cellNumbers.map((cellNumber) => {\r\n                    const rowNumber = Math.floor(cellNumber / 8);\r\n                    const rowCellNumber = cellNumber % 8\r\n\r\n                    const isValidCell = validCells.indexOf(cellNumber) > -1;\r\n\r\n                    const noOp = () => { };\r\n                    const handleClickFunction = (row: number, column: number) => handleCellClick(row, column);\r\n\r\n                    return (\r\n                        <GridListTile key={cellNumber} cols={1}>\r\n                            <div className={classes.cell}>\r\n                                {/* <FiberManualRecordIcon className={classes.token} style={{ color: cellColor }} /> */}\r\n                                <GameCell\r\n                                    row={rowNumber}\r\n                                    column={rowCellNumber}\r\n                                    isWhite={boardState[cellNumber]}\r\n                                    handleClick={isValidCell ? handleClickFunction : noOp}\r\n                                    isValid={isValidCell}\r\n                                    currentPlayerIsWhite={currentPlayerIsWhite}\r\n                                />\r\n                            </div>\r\n                        </GridListTile>\r\n                    );\r\n                })}\r\n            </GridList>\r\n\r\n            {/* <h1>currentPlayerIsWhite = [{currentPlayerIsWhite ? \"Yes\" : \"No\"}]</h1> */}\r\n\r\n            <br />\r\n            {currentPlayerContent}\r\n\r\n            <BottomNavigation\r\n                value={null}\r\n                onChange={(event, newValue) => {\r\n                    // setValue(newValue);\r\n                    console.log(newValue);\r\n\r\n                    if (newValue === 0) {\r\n                        restart();\r\n                        return;\r\n                    }\r\n\r\n                    if (newValue === 1) {\r\n                        selectRandomValidCell();\r\n                        return;\r\n                    }\r\n\r\n                    if (newValue === 2) {\r\n                        pass();\r\n                        return;\r\n                    }\r\n                }}\r\n                showLabels\r\n                className={classes.root}\r\n            >\r\n                <BottomNavigationAction label=\"Restart\" icon={<RestoreIcon />} />\r\n\r\n                {\r\n                    !isGameFinished &&\r\n                    validCells.length > 0 &&\r\n                    <BottomNavigationAction\r\n                        label=\"Random\"\r\n                        icon={<ShuffleIcon />}\r\n                    />\r\n                }\r\n\r\n                {\r\n                    !isGameFinished &&\r\n                    <BottomNavigationAction\r\n                        label={validCells.length === 0 ? \"Must Pass!\" : \"Pass\"}\r\n                        icon={<SentimentVeryDissatisfiedIcon />} />\r\n                }\r\n            </BottomNavigation>\r\n\r\n            {\r\n                isGameFinished &&\r\n                <GameFinishedSnackbar message={`Winner is ${winnerName}!`} />\r\n            }\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default GameBoardList;","import * as React from 'react';\r\nimport GameBoardList, { initialGameBoard } from './GameBoardList';\r\n\r\nexport interface GamePageListProps {\r\n}\r\n\r\nclass GamePageList extends React.Component<GamePageListProps, {}> {\r\n    render(): JSX.Element {\r\n        return (\r\n            <GameBoardList initialBoard={initialGameBoard} />\r\n        );\r\n    }\r\n}\r\n\r\nexport default GamePageList;\r\n","import React, { useState } from 'react';\r\nimport { Paper, Grid, ThemeProvider, createMuiTheme } from \"@material-ui/core\";\r\nimport Header from './components/Header';\r\nimport GamePageList from './components/GamePageList';\r\nimport { green } from '@material-ui/core/colors';\r\n\r\nfunction App() {\r\n\r\n  const [isDarkMode, setIsDarkMode] = useState(true);\r\n\r\n  const theme = createMuiTheme({\r\n    palette: {\r\n      type: isDarkMode ? \"dark\" : \"light\",\r\n\r\n      primary: green,\r\n      secondary: green,\r\n    }\r\n  });\r\n\r\n  return (\r\n    <ThemeProvider theme={theme}>\r\n      <Paper elevation={0} square style={{ height: \"100%\" }}>\r\n        <div style={{ paddingBottom: 100 }}>\r\n          <Grid container direction=\"column\">\r\n            <Grid item>\r\n              <Header isDarkMode={isDarkMode} setIsDarkMode={setIsDarkMode} />\r\n            </Grid>\r\n            <Grid item container>\r\n              <Grid item xs={false} sm={1} />\r\n              <Grid item xs={12} sm={10}>\r\n                {/* <BoardList /> */}\r\n                <GamePageList />\r\n              </Grid>\r\n              <Grid item xs={false} sm={1} />\r\n            </Grid>\r\n          </Grid>\r\n        </div>\r\n      </Paper>\r\n    </ThemeProvider>\r\n  );\r\n}\r\n\r\nexport default App;\r\n\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import 'react-app-polyfill/ie11';\r\nimport 'react-app-polyfill/stable';\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  // <React.StrictMode>\r\n  <App />\r\n  // </React.StrictMode>\r\n  ,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}